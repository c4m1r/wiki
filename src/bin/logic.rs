use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use serde::{Deserialize, Serialize};

/// Alternative deployment location
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeploymentMirror {
    /// Name/identifier for this mirror
    pub name: String,
    /// Base URL for this mirror (e.g., "https://mirror.example.com/wiki/")
    pub url: String,
    /// Optional IP address for direct access
    pub ip: Option<String>,
    /// Optional port number (defaults to 80 for HTTP, 443 for HTTPS)
    pub port: Option<u16>,
    /// Whether this mirror is active/enabled
    pub enabled: bool,
}

/// Configuration for a NervaWeb project
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NervaConfig {
    /// Project name
    pub name: String,
    /// Project description
    pub description: String,
    /// Author name
    pub author: String,
    /// Base URL for the site (used for relative links)
    pub base_url: String,
    /// Primary deployment URL (e.g., "https://c4m1r.github.io/wiki/")
    /// Supports subdirectories and custom domains
    pub primary_deployment_url: String,
    /// Default language
    pub default_language: String,
    /// Enabled languages
    pub enabled_languages: Vec<String>,
    /// Available themes
    pub themes: Vec<String>,
    /// Enable language switcher widget
    pub enable_language_switcher: bool,
    /// Enable theme switcher
    pub enable_theme_switcher: bool,
    /// Content directory (relative to project root)
    pub content_dir: String,
    /// Theme directory (relative to generator root)
    pub theme_dir: String,
    /// Assets directories
    pub assets_dirs: Vec<String>,
    /// Alternative deployment locations (mirrors)
    /// Supports unlimited mirrors for redundancy/load balancing
    pub deployment_mirrors: Vec<DeploymentMirror>,
}

impl Default for NervaConfig {
    fn default() -> Self {
        Self {
            name: "NervaWeb Site".to_string(),
            description: "Static website generated by NervaWeb".to_string(),
            author: "NervaWeb".to_string(),
            base_url: "/".to_string(),
            primary_deployment_url: "https://example.com/".to_string(), // Set your primary deployment URL (e.g., "https://c4m1r.github.io/wiki/")
            default_language: "ru".to_string(),
            enabled_languages: vec![
                "ru".to_string(), // Russian
                "en".to_string(), // English
                "es".to_string(), // Spanish
                "de".to_string(), // German
                "fr".to_string(), // French
                "it".to_string(), // Italian
                "pt".to_string(), // Portuguese
                "zh".to_string(), // Chinese
                "ja".to_string(), // Japanese
                "ko".to_string(), // Korean
                "ar".to_string(), // Arabic
                "hi".to_string(), // Hindi
            ],
            themes: vec![
                "hello-world".to_string(),
                "wiki".to_string(),
            ],
            enable_language_switcher: true,
            enable_theme_switcher: false,
            content_dir: "content".to_string(),
            theme_dir: "themes".to_string(),
            assets_dirs: vec![
                "css".to_string(),
                "js".to_string(),
                "fonts".to_string(),
            ],
            deployment_mirrors: vec![], // Empty by default - add mirrors as needed
        }
    }
}

impl NervaConfig {
    /// Load configuration from file
    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let content = fs::read_to_string(path)?;
        let config: NervaConfig = toml::from_str(&content)?;
        Ok(config)
    }

    /// Save configuration to file
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<(), Box<dyn std::error::Error>> {
        let content = toml::to_string_pretty(self)?;
        fs::write(path, content)?;
        Ok(())
    }

    /// Create a new configuration with default values
    pub fn new() -> Self {
        Self::default()
    }

    /// Check if a language is enabled
    pub fn is_language_enabled(&self, lang: &str) -> bool {
        self.enabled_languages.contains(&lang.to_string())
    }

    /// Get language display name
    pub fn get_language_name(&self, lang: &str) -> String {
        match lang {
            "ru" => "Русский".to_string(),
            "en" => "English".to_string(),
            "es" => "Español".to_string(),
            "de" => "Deutsch".to_string(),
            "fr" => "Français".to_string(),
            "it" => "Italiano".to_string(),
            "pt" => "Português".to_string(),
            "zh" => "中文".to_string(),
            "ja" => "日本語".to_string(),
            "ko" => "한국어".to_string(),
            "ar" => "العربية".to_string(),
            "hi" => "हिन्दी".to_string(),
            _ => lang.to_string(),
        }
    }

    /// Get language flag emoji
    pub fn get_language_flag(&self, lang: &str) -> &'static str {
        match lang {
            "ru" => "🇷🇺",
            "en" => "🇺🇸",
            "es" => "🇪🇸",
            "de" => "🇩🇪",
            "fr" => "🇫🇷",
            "it" => "🇮🇹",
            "pt" => "🇵🇹",
            "zh" => "🇨🇳",
            "ja" => "🇯🇵",
            "ko" => "🇰🇷",
            "ar" => "🇸🇦",
            "hi" => "🇮🇳",
            _ => "🏳️",
        }
    }

    /// Check if a theme is available
    pub fn is_theme_available(&self, theme: &str) -> bool {
        self.themes.contains(&theme.to_string())
    }

    /// Get all enabled languages with their display names and flags
    pub fn get_enabled_languages_info(&self) -> Vec<(String, String, String)> {
        self.enabled_languages
            .iter()
            .map(|lang| (
                lang.clone(),
                self.get_language_name(lang),
                self.get_language_flag(lang).to_string(),
            ))
            .collect()
    }

    /// Validate configuration
    pub fn validate(&self) -> Result<(), String> {
        if self.name.trim().is_empty() {
            return Err("Project name cannot be empty".to_string());
        }

        if self.enabled_languages.is_empty() {
            return Err("At least one language must be enabled".to_string());
        }

        if !self.enabled_languages.contains(&self.default_language) {
            return Err(format!("Default language '{}' is not in enabled languages list", self.default_language));
        }

        if self.themes.is_empty() {
            return Err("At least one theme must be available".to_string());
        }

        Ok(())
    }
}

/// Logic for NervaWeb static site generator
#[derive(Debug, Clone)]
pub struct NervaLogic {
    /// Generator root directory
    pub generator_root: PathBuf,
    /// Projects directory
    pub projects_dir: PathBuf,
    /// Output directory (good2go)
    pub output_dir: PathBuf,
}

impl NervaLogic {
    /// Create new logic instance
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let exe_path = std::env::current_exe()?;
        let exe_dir = exe_path.parent().unwrap();

        let generator_root = if exe_dir.ends_with("release") {
            exe_path
                .parent().unwrap() // target/release
                .parent().unwrap() // target
                .parent().unwrap() // bin
                .parent().unwrap() // src
                .parent().unwrap() // generator root
        } else {
            exe_dir // generator root
        };

        let projects_dir = generator_root.join("projects");
        let output_dir = generator_root.join("good2go");

        // Create base directories if they don't exist
        if !projects_dir.exists() {
            fs::create_dir_all(&projects_dir)?;
        }
        if !output_dir.exists() {
            fs::create_dir_all(&output_dir)?;
        }

        Ok(Self {
            generator_root: generator_root.to_path_buf(),
            projects_dir,
            output_dir,
        })
    }

    /// Get all projects
    pub fn get_projects(&self) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        if !self.projects_dir.exists() {
            return Ok(vec![]);
        }

        let mut projects = vec![];
        for entry in fs::read_dir(&self.projects_dir)? {
            let entry = entry?;
            if entry.path().is_dir() {
                if let Some(name) = entry.file_name().to_str() {
                    projects.push(name.to_string());
                }
            }
        }
        projects.sort();
        Ok(projects)
    }

    /// Get project path
    pub fn get_project_path(&self, name: &str) -> PathBuf {
        self.projects_dir.join(name)
    }

    /// Get project config path
    pub fn get_project_config_path(&self, name: &str) -> PathBuf {
        self.get_project_path(name).join("config.toml")
    }

    /// Get project content directory
    pub fn get_project_content_dir(&self, name: &str, config: &NervaConfig) -> PathBuf {
        self.get_project_path(name).join(&config.content_dir)
    }

    /// Get output path for project
    pub fn get_project_output_path(&self, name: &str) -> PathBuf {
        self.output_dir.join(name)
    }

    /// Load project configuration
    pub fn load_project_config(&self, name: &str) -> Result<NervaConfig, Box<dyn std::error::Error>> {
        let config_path = self.get_project_config_path(name);
        if config_path.exists() {
            match NervaConfig::load_from_file(config_path) {
                Ok(config) => Ok(config),
                Err(_) => {
                    // If config file exists but can't be loaded, return default
                    println!("Warning: Could not load config file, using defaults");
                    Ok(NervaConfig::default())
                }
            }
        } else {
            Ok(NervaConfig::default())
        }
    }

    /// Create new project
    pub fn create_project(&self, name: &str, description: Option<&str>, theme: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        println!("DEBUG: Creating project '{}'", name);
        let project_path = self.get_project_path(name);

        if project_path.exists() {
            return Err(format!("Project '{}' already exists", name).into());
        }

        // Create project directory
        fs::create_dir_all(&project_path)?;
        println!("DEBUG: Project directory created");

        // Create content directory
        let content_dir = project_path.join("content");
        fs::create_dir_all(&content_dir)?;

        // Copy default content from selected theme or fallback to hello-world
        let selected_theme = theme.unwrap_or("hello-world");
        let theme_dir = self.generator_root.join("src").join("themes").join(selected_theme);
        let default_content_src = theme_dir.join("default.md");
        let default_content_dst = content_dir.join("index.md");

        // Try selected theme first, then fallback to hello-world
        let content_to_copy = if default_content_src.exists() {
            default_content_src
        } else {
            // Fallback to hello-world theme
            let fallback_theme_dir = self.generator_root.join("src").join("themes").join("hello-world");
            let fallback_content_src = fallback_theme_dir.join("default.md");
            if fallback_content_src.exists() {
                fallback_content_src
            } else {
                // No theme content found, use inline fallback
                let fallback_content = format!(r#"---
title: "Hello World"
description: "Welcome to {}"
---

<!-- LANG: en -->
# Welcome to {}!

This is your first article created with NervaWeb.

## About

{}

<!-- LANG: ru -->
# Добро пожаловать в {}!

Это ваша первая статья, созданная с помощью NervaWeb.

## О проекте

{}
"#, name, name, description.unwrap_or("Project description"), name, description.unwrap_or("Описание проекта"));

                fs::write(&default_content_dst, fallback_content)?;
                return Ok(());
            }
        };

        fs::copy(&content_to_copy, &default_content_dst)?;

        // Create config.toml
        let mut config = NervaConfig::new();
        config.name = name.to_string();
        config.description = description.unwrap_or("Project description").to_string();
        config.save_to_file(self.get_project_config_path(name))?;

        // Ensure output directory exists
        fs::create_dir_all(self.get_project_output_path(name))?;

        Ok(())
    }

    /// Remove project
    pub fn remove_project(&self, name: &str) -> Result<(), Box<dyn std::error::Error>> {
        let project_path = self.get_project_path(name);
        if !project_path.exists() {
            return Err(format!("Project '{}' does not exist", name).into());
        }

        fs::remove_dir_all(&project_path)?;
        let output_path = self.get_project_output_path(name);
        if output_path.exists() {
            fs::remove_dir_all(&output_path)?;
        }

        Ok(())
    }
}

/// Command line arguments structure
#[derive(Debug)]
pub struct CliArgs {
    pub command: String,
    pub project: Option<String>,
    pub language: Option<String>,
    pub quiet: bool,
    pub theme: Option<String>,
    pub description: Option<String>,
}

impl CliArgs {
    pub fn new(args: Vec<String>) -> Self {
        let mut command = "help".to_string();
        let mut project = None;
        let mut language = None;
        let mut quiet = false;
        let mut theme = None;
        let mut description = None;

        let mut i = 1; // Skip program name
        while i < args.len() {
            match args[i].as_str() {
                "new" | "build" | "clear" | "content" | "help" | "version" => {
                    command = args[i].clone();
                    // For "new" command, next argument is project name
                    if args[i] == "new" && i + 1 < args.len() {
                        project = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--lang" | "-l" => {
                    if i + 1 < args.len() {
                        language = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--theme" | "-t" => {
                    if i + 1 < args.len() {
                        theme = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--desc" | "-d" => {
                    if i + 1 < args.len() {
                        description = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--quiet" | "-q" => {
                    quiet = true;
                }
                _ => {
                    // If command is not set and this looks like a command, set it
                    if command == "help" && !args[i].starts_with("-") {
                        command = args[i].clone();
                        // For build command, next argument might be project name
                        if args[i] == "build" && i + 1 < args.len() && !args[i + 1].starts_with("-") {
                            project = Some(args[i + 1].clone());
                            i += 1;
                        }
                    }
                }
            }
            i += 1;
        }

        Self {
            command,
            project,
            language,
            quiet,
            theme,
            description,
        }
    }
}

/// Available commands for NervaWeb
pub enum Command {
    New,
    Build,
    Clear,
    Content,
    Help,
    Version,
}

impl Command {
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "new" => Some(Command::New),
            "build" => Some(Command::Build),
            "clear" => Some(Command::Clear),
            "content" => Some(Command::Content),
            "help" => Some(Command::Help),
            "version" => Some(Command::Version),
            _ => None,
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            Command::New => "Create a new project",
            Command::Build => "Build the static website",
            Command::Clear => "Clear build artifacts and cache",
            Command::Content => "Count and list content files",
            Command::Help => "Show help information",
            Command::Version => "Show version information",
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = NervaConfig::default();
        assert_eq!(config.name, "NervaWeb Site");
        assert_eq!(config.default_language, "ru");
        assert!(config.is_language_enabled("en"));
        assert!(config.is_language_enabled("ru"));
        assert!(!config.is_language_enabled("xx"));
    }

    #[test]
    fn test_language_info() {
        let config = NervaConfig::default();
        let languages = config.get_enabled_languages_info();
        assert!(languages.len() > 0);
        assert!(languages.iter().any(|(code, _, _)| code == "ru"));
    }

    #[test]
    fn test_config_validation() {
        let mut config = NervaConfig::default();
        assert!(config.validate().is_ok());

        config.name = "".to_string();
        assert!(config.validate().is_err());

        config = NervaConfig::default();
        config.enabled_languages.clear();
        assert!(config.validate().is_err());
    }
}
