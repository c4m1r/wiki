use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use serde::{Deserialize, Serialize};

/// Configuration for a NervaWeb project
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NervaConfig {
    /// Project name
    pub name: String,
    /// Project description
    pub description: String,
    /// Author name
    pub author: String,
    /// Base URL for the site
    pub base_url: String,
    /// Default language
    pub default_language: String,
    /// Enabled languages
    pub enabled_languages: Vec<String>,
    /// Available themes
    pub themes: Vec<String>,
    /// Enable language switcher widget
    pub enable_language_switcher: bool,
    /// Enable theme switcher
    pub enable_theme_switcher: bool,
    /// Content directory (relative to project root)
    pub content_dir: String,
    /// Theme directory (relative to generator root)
    pub theme_dir: String,
    /// Assets directories
    pub assets_dirs: Vec<String>,
}

impl Default for NervaConfig {
    fn default() -> Self {
        Self {
            name: "NervaWeb Site".to_string(),
            description: "Static website generated by NervaWeb".to_string(),
            author: "NervaWeb".to_string(),
            base_url: "/".to_string(),
            default_language: "ru".to_string(),
            enabled_languages: vec![
                "ru".to_string(), // Russian
                "en".to_string(), // English
                "es".to_string(), // Spanish
                "de".to_string(), // German
                "fr".to_string(), // French
                "it".to_string(), // Italian
                "pt".to_string(), // Portuguese
                "zh".to_string(), // Chinese
                "ja".to_string(), // Japanese
                "ko".to_string(), // Korean
                "ar".to_string(), // Arabic
                "hi".to_string(), // Hindi
            ],
            themes: vec![
                "default".to_string(),
                "dark".to_string(),
                "light".to_string(),
            ],
            enable_language_switcher: true,
            enable_theme_switcher: false,
            content_dir: "content".to_string(),
            theme_dir: "theme".to_string(),
            assets_dirs: vec![
                "css".to_string(),
                "js".to_string(),
                "fonts".to_string(),
            ],
        }
    }
}

impl NervaConfig {
    /// Load configuration from file
    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let content = fs::read_to_string(path)?;
        let config: NervaConfig = toml::from_str(&content)?;
        Ok(config)
    }

    /// Save configuration to file
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<(), Box<dyn std::error::Error>> {
        let content = toml::to_string_pretty(self)?;
        fs::write(path, content)?;
        Ok(())
    }

    /// Create a new configuration with default values
    pub fn new() -> Self {
        Self::default()
    }

    /// Check if a language is enabled
    pub fn is_language_enabled(&self, lang: &str) -> bool {
        self.enabled_languages.contains(&lang.to_string())
    }

    /// Get language display name
    pub fn get_language_name(&self, lang: &str) -> String {
        match lang {
            "ru" => "–†—É—Å—Å–∫–∏–π".to_string(),
            "en" => "English".to_string(),
            "es" => "Espa√±ol".to_string(),
            "de" => "Deutsch".to_string(),
            "fr" => "Fran√ßais".to_string(),
            "it" => "Italiano".to_string(),
            "pt" => "Portugu√™s".to_string(),
            "zh" => "‰∏≠Êñá".to_string(),
            "ja" => "Êó•Êú¨Ë™û".to_string(),
            "ko" => "ÌïúÍµ≠Ïñ¥".to_string(),
            "ar" => "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©".to_string(),
            "hi" => "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä".to_string(),
            _ => lang.to_string(),
        }
    }

    /// Get language flag emoji
    pub fn get_language_flag(&self, lang: &str) -> &'static str {
        match lang {
            "ru" => "üá∑üá∫",
            "en" => "üá∫üá∏",
            "es" => "üá™üá∏",
            "de" => "üá©üá™",
            "fr" => "üá´üá∑",
            "it" => "üáÆüáπ",
            "pt" => "üáµüáπ",
            "zh" => "üá®üá≥",
            "ja" => "üáØüáµ",
            "ko" => "üá∞üá∑",
            "ar" => "üá∏üá¶",
            "hi" => "üáÆüá≥",
            _ => "üè≥Ô∏è",
        }
    }

    /// Check if a theme is available
    pub fn is_theme_available(&self, theme: &str) -> bool {
        self.themes.contains(&theme.to_string())
    }

    /// Get all enabled languages with their display names and flags
    pub fn get_enabled_languages_info(&self) -> Vec<(String, String, String)> {
        self.enabled_languages
            .iter()
            .map(|lang| (
                lang.clone(),
                self.get_language_name(lang),
                self.get_language_flag(lang).to_string(),
            ))
            .collect()
    }

    /// Validate configuration
    pub fn validate(&self) -> Result<(), String> {
        if self.name.trim().is_empty() {
            return Err("Project name cannot be empty".to_string());
        }

        if self.enabled_languages.is_empty() {
            return Err("At least one language must be enabled".to_string());
        }

        if !self.enabled_languages.contains(&self.default_language) {
            return Err(format!("Default language '{}' is not in enabled languages list", self.default_language));
        }

        if self.themes.is_empty() {
            return Err("At least one theme must be available".to_string());
        }

        Ok(())
    }
}

/// Logic for NervaWeb static site generator
#[derive(Debug, Clone)]
pub struct NervaLogic {
    /// Generator root directory
    pub generator_root: PathBuf,
    /// Projects directory
    pub projects_dir: PathBuf,
    /// Output directory (good2go)
    pub output_dir: PathBuf,
}

impl NervaLogic {
    /// Create new logic instance
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let exe_path = std::env::current_exe()?;
        let exe_dir = exe_path.parent().unwrap();

        let generator_root = if exe_dir.ends_with("release") {
            exe_path
                .parent().unwrap() // target/release
                .parent().unwrap() // target
                .parent().unwrap() // bin
                .parent().unwrap() // src
                .parent().unwrap() // generator root
        } else {
            exe_dir // generator root
        };

        let projects_dir = generator_root.join("projects");
        let output_dir = generator_root.join("good2go");

        Ok(Self {
            generator_root: generator_root.to_path_buf(),
            projects_dir,
            output_dir,
        })
    }

    /// Get all projects
    pub fn get_projects(&self) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        if !self.projects_dir.exists() {
            return Ok(vec![]);
        }

        let mut projects = vec![];
        for entry in fs::read_dir(&self.projects_dir)? {
            let entry = entry?;
            if entry.path().is_dir() {
                if let Some(name) = entry.file_name().to_str() {
                    projects.push(name.to_string());
                }
            }
        }
        projects.sort();
        Ok(projects)
    }

    /// Get project path
    pub fn get_project_path(&self, name: &str) -> PathBuf {
        self.projects_dir.join(name)
    }

    /// Get project config path
    pub fn get_project_config_path(&self, name: &str) -> PathBuf {
        self.get_project_path(name).join("config.toml")
    }

    /// Get project content directory
    pub fn get_project_content_dir(&self, name: &str, config: &NervaConfig) -> PathBuf {
        self.get_project_path(name).join(&config.content_dir)
    }

    /// Get output path for project
    pub fn get_project_output_path(&self, name: &str) -> PathBuf {
        self.output_dir.join(name)
    }

    /// Load project configuration
    pub fn load_project_config(&self, name: &str) -> Result<NervaConfig, Box<dyn std::error::Error>> {
        let config_path = self.get_project_config_path(name);
        if config_path.exists() {
            NervaConfig::load_from_file(config_path)
        } else {
            Ok(NervaConfig::default())
        }
    }

    /// Create new project
    pub fn create_project(&self, name: &str, description: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let project_path = self.get_project_path(name);

        if project_path.exists() {
            return Err(format!("Project '{}' already exists", name).into());
        }

        // Create project directory
        fs::create_dir_all(&project_path)?;

        // Create content directory
        let content_dir = project_path.join("content");
        fs::create_dir_all(&content_dir)?;

        // Create default index.md
        let index_content = format!(r#"---
title:
  ru: "–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞"
  en: "Home page"
---

<!-- LANG: ru -->
# –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!

–≠—Ç–æ –≥–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–æ–µ–∫—Ç–∞ **{}**.

## –û –ø—Ä–æ–µ–∫—Ç–µ

{}

<!-- END_LANG -->

<!-- LANG: en -->
# Welcome!

This is the home page of the **{}** project.

## About

{}

<!-- END_LANG -->
"#, name, description.unwrap_or("–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞"), name, description.unwrap_or("Project description"));

        fs::write(content_dir.join("index.md"), index_content)?;

        // Create config.toml
        let mut config = NervaConfig::new();
        config.name = name.to_string();
        config.description = description.unwrap_or("Project description").to_string();
        config.save_to_file(self.get_project_config_path(name))?;

        // Ensure output directory exists
        fs::create_dir_all(self.get_project_output_path(name))?;

        Ok(())
    }

    /// Remove project
    pub fn remove_project(&self, name: &str) -> Result<(), Box<dyn std::error::Error>> {
        let project_path = self.get_project_path(name);
        if !project_path.exists() {
            return Err(format!("Project '{}' does not exist", name).into());
        }

        fs::remove_dir_all(&project_path)?;
        let output_path = self.get_project_output_path(name);
        if output_path.exists() {
            fs::remove_dir_all(&output_path)?;
        }

        Ok(())
    }
}

/// Command line arguments structure
#[derive(Debug)]
pub struct CliArgs {
    pub command: String,
    pub project: Option<String>,
    pub language: Option<String>,
    pub quiet: bool,
    pub theme: Option<String>,
    pub description: Option<String>,
}

impl CliArgs {
    pub fn new(args: Vec<String>) -> Self {
        let mut command = "help".to_string();
        let mut project = None;
        let mut language = None;
        let mut quiet = false;
        let mut theme = None;
        let mut description = None;

        let mut i = 1; // Skip program name
        while i < args.len() {
            match args[i].as_str() {
                "new" | "build" | "clear" | "content" | "help" | "version" => {
                    command = args[i].clone();
                    // For "new" command, next argument is project name
                    if args[i] == "new" && i + 1 < args.len() {
                        project = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--lang" | "-l" => {
                    if i + 1 < args.len() {
                        language = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--theme" | "-t" => {
                    if i + 1 < args.len() {
                        theme = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--desc" | "-d" => {
                    if i + 1 < args.len() {
                        description = Some(args[i + 1].clone());
                        i += 1;
                    }
                }
                "--quiet" | "-q" => {
                    quiet = true;
                }
                _ => {
                    // If command is not set and this looks like a command, set it
                    if command == "help" && !args[i].starts_with("-") {
                        command = args[i].clone();
                        // For build command, next argument might be project name
                        if args[i] == "build" && i + 1 < args.len() && !args[i + 1].starts_with("-") {
                            project = Some(args[i + 1].clone());
                            i += 1;
                        }
                    }
                }
            }
            i += 1;
        }

        Self {
            command,
            project,
            language,
            quiet,
            theme,
            description,
        }
    }
}

/// Available commands for NervaWeb
pub enum Command {
    New,
    Build,
    Clear,
    Content,
    Help,
    Version,
}

impl Command {
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "new" => Some(Command::New),
            "build" => Some(Command::Build),
            "clear" => Some(Command::Clear),
            "content" => Some(Command::Content),
            "help" => Some(Command::Help),
            "version" => Some(Command::Version),
            _ => None,
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            Command::New => "Create a new project",
            Command::Build => "Build the static website",
            Command::Clear => "Clear build artifacts and cache",
            Command::Content => "Count and list content files",
            Command::Help => "Show help information",
            Command::Version => "Show version information",
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = NervaConfig::default();
        assert_eq!(config.name, "NervaWeb Site");
        assert_eq!(config.default_language, "ru");
        assert!(config.is_language_enabled("en"));
        assert!(config.is_language_enabled("ru"));
        assert!(!config.is_language_enabled("xx"));
    }

    #[test]
    fn test_language_info() {
        let config = NervaConfig::default();
        let languages = config.get_enabled_languages_info();
        assert!(languages.len() > 0);
        assert!(languages.iter().any(|(code, _, _)| code == "ru"));
    }

    #[test]
    fn test_config_validation() {
        let mut config = NervaConfig::default();
        assert!(config.validate().is_ok());

        config.name = "".to_string();
        assert!(config.validate().is_err());

        config = NervaConfig::default();
        config.enabled_languages.clear();
        assert!(config.validate().is_err());
    }
}
